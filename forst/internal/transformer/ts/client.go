package transformerts

import (
	"fmt"
	"strings"
)

// generateClientStructure generates the new Prisma-like client structure
func (t *TypeScriptTransformer) generateClientStructure() {
	if t.Output.PackageName == "" {
		return
	}

	// Generate types file
	t.generateTypesFile()

	// Generate per-package client code
	t.generatePackageClient()

	// Generate main client
	t.generateMainClient()
}

// generateTypesFile generates the centralized types file
func (t *TypeScriptTransformer) generateTypesFile() {
	var lines []string

	lines = append(lines, "// Auto-generated types for Forst client")
	lines = append(lines, "// Generated by Forst TypeScript Transformer")
	lines = append(lines, "")

	// Add all types
	if len(t.Output.Types) > 0 {
		lines = append(lines, "// Type definitions")
		lines = append(lines, strings.Join(t.Output.Types, "\n\n"))
		lines = append(lines, "")
	}

	// Add function signatures
	if len(t.Output.Functions) > 0 {
		lines = append(lines, "// Function signatures")
		lines = append(lines, strings.Join(t.Output.Functions, "\n\n"))
		lines = append(lines, "")
	}

	t.Output.TypesFile = strings.Join(lines, "\n")
}

// generatePackageClient generates the per-package client code
func (t *TypeScriptTransformer) generatePackageClient() {
	var lines []string

	lines = append(lines, fmt.Sprintf("// Auto-generated client for %s package", t.Output.PackageName))
	lines = append(lines, "// Generated by Forst TypeScript Transformer")
	lines = append(lines, "")
	lines = append(lines, "import { ForstClient as SidecarClient } from '@forst/sidecar';")
	lines = append(lines, "import * as types from './types';")
	lines = append(lines, "")

	// Generate package namespace
	lines = append(lines, fmt.Sprintf("export const %s = (client: SidecarClient) => ({", t.Output.PackageName))

	// Add function implementations
	for _, function := range t.Output.Functions {
		funcName := strings.TrimPrefix(function, "export function ")
		funcName = strings.Split(funcName, "(")[0]

		// Extract parameters
		paramPart := ""
		paramNames := []string{}
		if strings.Contains(function, "(") && strings.Contains(function, ")") {
			start := strings.Index(function, "(") + 1
			end := strings.Index(function, ")")
			paramPart = function[start:end]

			// Parse parameter names
			if paramPart != "" {
				params := strings.Split(paramPart, ", ")
				for _, param := range params {
					if strings.Contains(param, ":") {
						paramName := strings.Split(param, ":")[0]
						paramNames = append(paramNames, paramName)
					}
				}
			}
		}

		// Generate implementation
		impl := fmt.Sprintf("  %s: async (%s) => {", funcName, paramPart)

		// Create args object for single parameter, or use spread for multiple
		if len(paramNames) == 1 {
			impl += fmt.Sprintf("\n    const response = await client.invokeFunction('%s', '%s', %s);",
				t.Output.PackageName, funcName, paramNames[0])
		} else if len(paramNames) > 1 {
			impl += fmt.Sprintf("\n    const response = await client.invokeFunction('%s', '%s', { %s });",
				t.Output.PackageName, funcName, strings.Join(paramNames, ", "))
		} else {
			impl += fmt.Sprintf("\n    const response = await client.invokeFunction('%s', '%s', {});",
				t.Output.PackageName, funcName)
		}

		impl += "\n    if (!response.success) {"
		impl += fmt.Sprintf("\n      throw new Error(response.error || '%s.%s failed');",
			t.Output.PackageName, funcName)
		impl += "\n    }"
		impl += "\n    return response.result;"
		impl += "\n  },"

		lines = append(lines, impl)
	}

	lines = append(lines, "});")
	lines = append(lines, "")

	t.Output.ClientCode = lines
}

// generateMainClient generates the main client class
func (t *TypeScriptTransformer) generateMainClient() {
	var lines []string

	lines = append(lines, "// Auto-generated Forst Client")
	lines = append(lines, "// Generated by Forst TypeScript Transformer")
	lines = append(lines, "")
	lines = append(lines, "import { ForstClient as SidecarClient } from '@forst/sidecar';")
	lines = append(lines, fmt.Sprintf("import { %s } from './%s.client';", t.Output.PackageName, t.Output.PackageName))
	lines = append(lines, "import * as types from './types';")
	lines = append(lines, "")
	lines = append(lines, "export interface ForstClientConfig {")
	lines = append(lines, "  baseUrl?: string;")
	lines = append(lines, "  timeout?: number;")
	lines = append(lines, "  retries?: number;")
	lines = append(lines, "}")
	lines = append(lines, "")
	lines = append(lines, "export class ForstClient {")
	lines = append(lines, "  private client: SidecarClient;")
	lines = append(lines, fmt.Sprintf("  public %s: ReturnType<typeof %s>;", t.Output.PackageName, t.Output.PackageName))
	lines = append(lines, "")
	lines = append(lines, "  constructor(config?: ForstClientConfig) {")
	lines = append(lines, "    const defaultConfig = {")
	lines = append(lines, "      baseUrl: process.env.FORST_BASE_URL || 'http://localhost:8080',")
	lines = append(lines, "      timeout: 30000,")
	lines = append(lines, "      retries: 3,")
	lines = append(lines, "      ...config,")
	lines = append(lines, "    };")
	lines = append(lines, "")
	lines = append(lines, "    this.client = new SidecarClient(defaultConfig);")
	lines = append(lines, fmt.Sprintf("    this.%s = %s(this.client);", t.Output.PackageName, t.Output.PackageName))
	lines = append(lines, "  }")
	lines = append(lines, "}")
	lines = append(lines, "")
	lines = append(lines, "// Export types")
	lines = append(lines, "export * from './types';")
	lines = append(lines, "")
	lines = append(lines, "// Export default")
	lines = append(lines, "export default ForstClient;")

	t.Output.MainClient = strings.Join(lines, "\n")
}
